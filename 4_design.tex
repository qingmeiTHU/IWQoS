\newcommand{\Mod}[1]{\text{ (mod } #1\text{)}}
\wenfei{check key frame and keyframe, check bit rate and bitrate.}
\section{\name Solution}
Based on the intuitions above, we review the design of RTMP and customize the protocol in three levels. First, we tune the GoP size to reduce the dependency between frame so that ``cascading effect'' is mitigated; second, we improve the frame drop strategy within GoP to avoid the drop as much as possible; third, we devise a bitrate adaptation algorithm across GoP for long-term wireless bandwidth degradation.

%In particular, GVBR optimizes the adaptation at frame-level (Section~\ref{subsec:drop-strategy}), as well as GOP-level
(Section~\ref{subsec:adaptive-bitrate}).
\subsection{Determining GoP Size}
Large GoP size causes ``cascading effect'' when the network suffers from transient bandwidth drop; but small GoP causes low compression ration, causing frame resolution to be small. Thus, we find the best GoP size as the tradeoff between drop resistance and resolution. 

We compute best GoP size by using streaming histories to find the optimal GoP size. We set up a target metric to measure the quality of the whole video, replay the video with historical network conditions, tune GoP size in each replay, and find out the GoP size with the best video quality. This computation can be done offline in a cloud, CDN server, or in the streaming device, and the GOP size is configured as a parameter for next video streaming session.

In our implementation, we use SSIM \wenfei{explain it} as the metric for video quality. SSIM is XXXX? Then we vary GoP size, and figure out the minimum GoP size that can keep SSIM to be within [XX\%-100\%]\wenfei{the value} of the SSIM of the original video.


\subsection{Smart Drop Strategy}
\label{subsec:drop-strategy}
In the runtime with GoP size configure, a frame drop logic is needed for transient network degradation. We first theoretically figure out the best possible drop decision (i.e., best video quality) that can be made assuming the network degradation is known beforehand. Then we design an online algorithm that has low complexity and is suitable for mobile devices.

\subsubsection{Problem Analysis}
\input{fig/variables.tex}
\input{fig/ip.tex}
We first figure out the best video quality that can be achieved by making frame drop decisions.
Assuming the pace of video frame and network bandwidth are known, there exists an optimal scheduling regarding maximizing audience QoE within the system constraints (bandwidth and queue timeliness length). A group of pictures comprise three kinds of frames, namely I/P/B frames; for simplicity here, we delete the B frame to study the fundamental problem. The problem can be formulated by integer programming (Figure~\ref{fig:ip-program}). Symbols are defined in Table~\ref{tbl:term}. We discretize time into time stamps from $0$ to $T$, and assume the frame with index $i$ is generated at time $i$. We define $x_{ij}$, $y_{ij}$, $z_{ij}$ as 0/1 variables to describe whether a packet is in the queue, sent or dropped respectively.

\textbf{Frame conservation constraints.}
Frame $i$ is generated at time $i$, and after that, it is either in the queue or sent or dropped (1-2).
After a packet is removed from the queue, it would never be enqueued (3).
After a packet is sent/dropped, it is permanently sent/ dropped afterward (4-5).

\textbf{Bandwidth constraints.} \wenfei{rewrite this.}
The determination of sending strategy, the decision of $y_{ij}$, is also an interesting and important problem. Nonetheless, for simplicity, in this paper we just assume that the broadcaster sends as many as possible. This means, at time $j$ we send out all the possible frames and set the corresponding $y_{ij}$ to true. At any time, the number of frames sent should not exceed the available network bandwidth. In line with these constraints, the max frame index $M_{j}$, is calculated by maximizing the function.
\begin{align}
M_j = argmax \Sigma_k (1-y_{k,j-1})(1-z_{k,j-1}) \leq C_{j}
\end{align}
In addition, the frame that can be send must be not dropped.

\textbf{Timeliness constraint.}
A frame is ``fresh'' if it is sent with in ``$T_1$''. That is, a frame is either sent or drop after time $T_1$ of its generation (7).

\textbf{Decodability constraints.} The final delivered frames must be decodable. Otherwise, they would be a waste of network bandwidth. I frames are always decodable. A P frame is decodable if and only if its preceding I or P frame is decodable (8).

\textbf{Optimization goal.} The goal of the IP model is to maximize the delivered frames.
Compared with prior work~\cite{singh2004dynamic}, this IP model has timeliness and decodability in consideration, thus it is more suitable for personalized live streaming.


\subsubsection{Greedy Algorithm}
\input{fig/greedy_cbr.tex}
IP can achieve the offline optimal. Nevertheless long-term bandwidth is unknowable ahead of time, and the computational complexity is too high for mobile devices to run it. Thus, IP cannot be applied in practice. Consequently, an online drop strategy is necessary.

\wenfei{rewrite this paragraph.} Considering the encode dependency within a GoP, we propose a modified dropping algorithm, GreedyDrop (Algorithm ~\ref{alg:greedy-drop}). Differing from dropping all the P frames in buffer by default, GreedyDrop optimizes one more case, where two or more GoPs coexist in buffer. GreedyDrop drops all the P frames until the next keyframe so the latest GoP can be reserved and our algorithm avoid frame dropping at least one GoP.

We implemented the online algorithm in \name. In experiments where we control network bandwidth, we can compare the effect of the IP approach and the greedy algorithm.

\subsection{Adaptive Bitrate}
\label{subsec:adaptive-bitrate}
\subsubsection{Problem Formulation}
\input{fig/vbr_variable.tex}
\input{fig/vbr.tex}
\wenfei{rewrite these formulas as that in Figure~\ref{fig:ip-program}.}

To deal with long-term bandwidth fading, we adopt an adaptive bitrate approach. We still first explore the theoretically best quality that can be achieved by tuning the bitrate. We then design an online algorithm for mobile devices.

We introduce a variable $R_{i}$. $R_{i}$ represents the bitrate of the $i$ frame. For variable bitrate, calculating how many frames can be sent is a tricky problem, because different frames have different sizes.
The utility function can be formulated as in Figure XX\wenfei{XX},
% equation \ref{vbr-formulation}, 
the first item is the bitrate utility, the second represents the bitrate switch penalty, the last item equals the frame drops penalty. Variables are all defined in Table~\ref{tbl:vbrval}. Variables $\alpha$ and $\beta$ are the utility parameter of bitrate switch and frame drops. $sgn$ is the sign function. When the variable greater than zero, it equals 1; otherwise it equals zero. $mod$ is the operation of taking the remainder.

\textbf{Bitrate Constraint.} Constraint (\ref{vbr-bitrate}) requires that bitrate within one GoP should be identical.

\textbf{Bandwidth Constraint.} Equation (\ref{vbr-send}) calculates the maximum number of sendable GoPs within the limited bandwidth.

\textbf{Timeliness Constraint.} Constraint (\ref{vbr-drop}) judges whether the remaining time after sending exceeds the buffer threshold and constraint (\ref{vbr-drop-no}) give the number of dropped frames in time $j$.

\textbf{State Transition.} Constraints (\ref{vbr-bitrate-next}, \ref{vbr-bitrate-spec}, \ref{vbr-time-next}, \ref{vbr-time-spec}, \ref{vbr-time-spec2}) reflect the state transition of the bitrate and remaining time of several GoPs in the buffer. Equations (\ref{vbr-gop-no}) describes the number of GoPs in the next time slot $j+1$, and the last two items $1-mod(j,M)$ represents whether the $j-th$ frame is the keyframe.

Offline optimal solution is hard to calculate. Assume for each GoP, the broadcaster can choose one from total $M$ bitrate candidates. For a $T$ GoP decision, the computation complexity equals $M^T$, an exponential complexity.

\subsubsection{Effective Solution} 
\input{fig/greedy_vbr.tex}
\textbf{Algorithm Description.} Issue with exponential complexity is hard to calculate in limited time. In addition, the offline optimal is on the basis of off-the-shelf knowledge of future bandwidth. Such long-term bandwidth prediction is inaccurate. An intuitive idea is to change the bitrate following the bandwidth. Moreover, the remaining data size in the buffer can also be adopted. At time $j$, the broadcaster carries out the following two key steps, as shown in Greedy Variable Bitrate (GVBR) (Algorithm ~\ref{alg:greedy-vbr}). $\eta$ is the tuning parameter of frame drops and bitrate.

$1.$ Bandwidth estimation. According to Festive~\cite{jiang2014improving} and MPC~\cite{yin2015control}, harmonic mean is a useful method of estimating the future bandwidth. Nevertheless, proposing a prediction mechanism is not our major concern. With more accurate bandwidth estimations, our method performs much more satisfactory.

$2.$ Bitrate selection. To avoid frequent frame dropping, an appropriate bitrate is essential. Given the future bandwidth $C_j$ and the data size in buffer $Rest$, a heuristic method is to choose the largest available bitrate lower than $(C_j-Rest)/\eta$.
